<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometries</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="../build/three.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script src="../src/extras/geometries/BoxGeometry2.js"></script>
		<script src="../src/extras/geometries/PlaneGeometry2.js"></script>
		<script src="../src/objects/MergedMesh.js"></script>
		<script src="js/libs/dat.gui.min.js"></script>
		<script src="js/BufferGeometryUtils.js"></script>
		<script src="http://jeromeetienne.github.io/threex.rendererstats/threex.rendererstats.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats, renderstats;

			var camera, scene, renderer, projector, raycaster;
			var mouse = new THREE.Vector2();

			var materials = [], shapes = [];
			var boxes = [];
			var merged;
			var updatetimer = false;
			var lastsettings = {};

			var settings = {
				objects: 200,
				percentInMotion: 10,
				materials: 3,
				shapes: 3,
				viewingArea: 100,
			}

			var gui = new dat.GUI();
			gui.add( settings, "objects", 1, 10000, settings.objects ).step(1).onChange(updateObjectCount);
			gui.add( settings, "percentInMotion", 0, 100, settings.percentInMotion ).step(1);
			gui.add( settings, "materials", 1, 10, settings.materials ).step(1).onChange(updateObjectCount);
			gui.add( settings, "shapes", 1, 10, settings.shapes ).step(1).onChange(updateObjectCount);
			gui.add( settings, "viewingArea", 10, 1000, settings.viewingArea ).step(10).onChange(updateObjectCount);

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.y = 0;
				camera.position.z = settings.viewingArea;

				scene = new THREE.Scene();

				scene.add( new THREE.AmbientLight( 0x404040 ) );

				var light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 0, 0, 1 );
				scene.add( light );

				projector = new THREE.Projector();
				raycaster = new THREE.Raycaster();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				renderstats = new THREEx.RendererStats()
				renderstats.domElement.style.position = 'absolute'
				renderstats.domElement.style.left = '0px'
				renderstats.domElement.style.bottom = '0px'
				document.body.appendChild( renderstats.domElement )

				merged = new THREE.MergedMesh();

				updateObjects();

				scene.add(merged);

				window.addEventListener( 'resize', onWindowResize, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousewheel', onDocumentMouseWheel, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}
			function onDocumentMouseWheel( event ) {

				camera.position.z -= event.wheelDelta / 10;

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();
				renderstats.update(renderer);

			}

			function render() {

				var timer = Date.now() * 0.0001;

				camera.position.x = ( (mouse.x * window.innerWidth) - camera.position.x ) * .05;
				camera.position.y = ( - (mouse.y * window.innerHeight) - camera.position.y ) * .05;

				camera.lookAt( scene.position );

				var numobjects = boxes.length;
				if (settings.percentInMotion > 0) {
					// Animate a configurable percentage of the objects in the scene
					var inmotion = Math.floor(numobjects * (settings.percentInMotion / 100));
					var startobj = Math.floor(timer) % numobjects;
					for (var i = startobj; i < startobj + inmotion; i++) {
						var object = boxes[i % boxes.length];
						if (object) {
							// All of this weirdness is to make all the objects spin in different directions at different speeds
							var dir1 = (object.id % 2 == 0 ? -1 : 1);
							var dir2 = (object.id % 3 == 0 ? -1 : 1);
							var dir3 = (object.id % 4 == 0 ? -1 : 1);
							var dir4 = (object.id % 5 == 0 ? -1 : 1);
							var dir5 = (object.id % 6 == 0 ? -1 : 1);
							var dir6 = (object.id % 7 == 0 ? -1 : 1);
							object.rotation.x = timer * 10 * Math.sin(object.id) * dir1 * dir4;
							object.rotation.y = timer * 10 * Math.cos(object.id) * dir2 * dir5;
							object.rotation.z = timer * 5 * dir3 * dir6;
						}
					}
				}
			

				renderer.render( scene, camera );

			}

			function updateObjectCount() {
				if (updatetimer) {
					clearTimeout(updatetimer);
				}
				updatetimer = setTimeout(updateObjects, 250);
			}
			function createMaterials() {
				if (materials.length < settings.materials) {
					for (var i = materials.length; i < settings.materials; i++) {
						materials[i] = new THREE.MeshLambertMaterial({ color: 0xffffff * Math.random() });
					}
				}
			}
			function createShapes() {
				var types = ['box', 'sphere', 'cylinder', 'cone'];
				if (shapes.length < settings.shapes) {
					for (var i = shapes.length; i < settings.shapes; i++) {
						//shapes[i] = new THREE.BoxGeometry2(Math.random() * 10, Math.random() * 10, Math.random() * 10);
						var type = types[Math.floor(Math.random() * 1000) % types.length];
						switch (type) {
							case 'box':
								shapes[i] = new THREE.BoxGeometry(Math.random() * 10, Math.random() * 10, Math.random() * 10);
								break;
							case 'sphere':
								shapes[i] = new THREE.SphereGeometry(Math.random() * 10 + .5);
								break;
							case 'cylinder':
								var r = Math.random() * 5 + .5;
								shapes[i] = new THREE.CylinderGeometry(r, r, Math.random() * 10 + 5);
								break;
							case 'cone':
								shapes[i] = new THREE.CylinderGeometry(0, Math.random() * 5 + .5, Math.random() * 10 + 5);
								break;
						}
						shapes[i].computeFaceNormals();
					}
				}
			}
			function updateObjects() {
				updatetimer = false;
				console.log('do update!');
				this.createShapes();
				this.createMaterials();

				// If we have more boxes than we need, unmerge the ones we don't need anymore
				while (boxes.length >= settings.objects) {
					merged.unmerge(boxes.pop());
				}

				// If we've removed materials, get rid of all boxes which used ones which aren't in use anymore
				if (settings.materials > lastsettings.materials) {
					while (boxes.length > 0) merged.unmerge(boxes.pop()); // remove all!
				} else if (settings.materials < lastsettings.materials) {
					for (var i = boxes.length - 1; i >= 0; i--) {
						if (materials.indexOf(boxes[i].material) > settings.materials - 1) {
							merged.unmerge(boxes[i]);
							boxes.splice(i, 1);
						}
					}
				}
				// If we've removed shapes, get rid of all boxes which used ones which aren't in use anymore
				if (settings.shapes > lastsettings.shapes) {
					while (boxes.length > 0) merged.unmerge(boxes.pop()); // remove all!
				} else if (settings.shapes < lastsettings.shapes) {
					for (var i = boxes.length - 1; i >= 0; i--) {
						if (shapes.indexOf(boxes[i].geometry) > settings.shapes - 1) {
							merged.unmerge(boxes[i]);
							boxes.splice(i, 1);
						}
					}
				}


				// If we need more boxes, create them and merge them into the MergedMesh
				for (var i = boxes.length; i < settings.objects; i++) {
					var newbox = new THREE.Mesh(shapes[Math.round(Math.random() * 1000) % settings.shapes], materials[Math.round(Math.random() * 1000) % settings.materials]);
					//newbox.position.set(2 * i, 0, -5);

					boxes.push(newbox);
					merged.merge(newbox);
				}
				for (var i = 0; i < boxes.length; i++) {
					boxes[i].position.set(Math.random() * settings.viewingArea - settings.viewingArea/2, Math.random() * settings.viewingArea - settings.viewingArea / 2, Math.random() * settings.viewingArea - settings.viewingArea / 2);
					boxes[i].rotation.set((Math.random() * 2 * Math.PI) - Math.PI, (Math.random() * 2 * Math.PI) - Math.PI, (Math.random() * 2 * Math.PI) - Math.PI);
				}

				//merged.forceUpdate(); // FIXME - shouldn't be necessary

				lastsettings.objects = settings.objects;
				lastsettings.materials = settings.materials;
				lastsettings.shapes = settings.shapes;
			}
		</script>

	</body>
</html>


